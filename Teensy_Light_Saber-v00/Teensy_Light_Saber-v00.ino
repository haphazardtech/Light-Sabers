/*******************************************************************************
 * TERMINOLOGY AND HOW THEY ARE USED WITHIN
 *
 * INIT: Shorthand for "Initialize", most commonly used when breaking up the
 * single "setup" function by with smaller, more focused routines.
 *
 * RETRIEVE: Use when a value is grabbed from an external source like an input
 * pin. Not to be confused with "get" which tends to grab a value from an
 * internal source like a class member.
 *
 * MODE vs. BEHAVIOR: Modes are more more general,higher level and used to group
 * specific behaviors. You can only have one mode or behavior at a time.
 ******************************************************************************/

/*******************************************************************************
 * HARDWARE:
 *
 *  Should work with most Arduino or compatable boards with at least 3
 *  interrupt and 1 analog pin. Was built/tested on a Teensy 3.6.
 *
 * - 1 strip of 60 WS2812B addressable LED's... "Neopixels".
 * - 1 10K Ohm poteniomter.
 * - 3 momentary closed push buttons.
 * - 1 HN74HC14 Inverted Schmitt Trigger (Hardware Debounce).
 * - 3 100K Ohm resistors (Hardware Debounce).
 * - 3 10K Ohm resistors (Hardware Debounce).
 * - 3 .1 uF ceramic capacitors (Hardware Debounce).
 *
 ******************************************************************************/


/*******************************************************************************
 * INCLUDES: Include all required libraries here.
 ******************************************************************************/
#include <FastLED.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

/*******************************************************************************
 * DEBUG: Throughout the code the serial monitor is used to help with debugging.
 * When debugging is not wanted (like when put to final use, in an actual sword
 * and no monitor is attached) simply comment out this definition.
 ******************************************************************************/
#define DEBUG

/*******************************************************************************
 * AUDIO DESIGN: Most of this section is generated by the Teensy Audio Design
 * Tool. You could go crazy here and add an input for each audio file, set up
 * fancy fades and effects but again, crazy for testing. You only need one
 * "AudioPlaySerialflahRaw" object for each audio files that may be playing
 * concurrently. If one sound always ends before another begins then one object
 * can just play one after another.
 ******************************************************************************/

// GUItool: begin automatically generated code
AudioPlaySerialflashRaw  extendSoundPlayer;
AudioOutputAnalog        dac;
AudioConnection          patchCord1(extendSoundPlayer, dac);
// GUItool: end automatically generated code

/*******************************************************************************
 * PROP SHIELD SPECIFIC: Define pins to enable used features.
 ******************************************************************************/

#define ENABLE_AMP_PIN 5
#define ENABLE_FLASH_PIN 6

/*******************************************************************************
 * AUDIO FILES: Write something about organizing the audio files here...
 ******************************************************************************/

char extendBladeTrack[] = "ON11.raw";

 // #define NUM_TRACKS 1
 // char fileNames[NUM_TRACKS][9] = {
 //   "ON11.raw"
 // };

/*******************************************************************************
 * INPUTS: Specify pins used by attached input hardware.
 ******************************************************************************/
#define TOGGLE_BLADE_PIN 23
#define CHANGE_MODE_PIN 22
#define CYCLE_BEHAVIOR_PIN 21
#define HUE_PIN A0

/*******************************************************************************
 * LIGHT STRIPS: Specify constants and variables necessary for light strip
 * operation.
 *
 * This setup is specific to FastLED but should work for Adafruit's Neopixel
 * library as well.
 ******************************************************************************/
#define PIXEL_TYPE WS2812B
#define COLOR_ORDER GRB // GRB for WS2812B's
#define LIGHT_STRIP_PIN 10
#define NUM_PIXELS 60

CHSV pixelsHSV[NUM_PIXELS];
CRGB pixelsRGB[NUM_PIXELS];
int currentHue;
int baseSaturation;
int baseValue;

/*******************************************************************************
 * BLADE BEHAVIORS: The idea here is to state how the blade is to act or in
 * other words, specify possible "behaviors". Each behavior is associated with a
 * specific animation, sound effects, etc.
 *
 * NOTE: These seem like they would be better served as specialized classes.
 * They'd likely have enough in common to be worth it but this will do for now
 * and will come back to if time permits?
 ******************************************************************************/
enum bladeBehavior {

    // Normal Blade Behaviors
    stable,
    unstable,
    pulsing,

    // Party Behaviors
    rainbow,
    rainbowWithGlitter,
    verticalRainbow,
    confetti,
    cylon,
    bpm,
    juggle

};

/*******************************************************************************
 * INTERRUPT VARIABLES: These are control variables used by the Interrupt
 * Service Routines (ISRs).
 ******************************************************************************/
volatile boolean shouldBladeToggle;
volatile boolean shouldModeChange;
volatile boolean shouldBehaviorChange;

/*******************************************************************************
 * STATE VARIABLES: Control variables that keep track of the blades current
 * modes of operation.
 ******************************************************************************/

boolean isBladeExtended;
boolean isPartyMode;
boolean behaviorChanged;
bladeBehavior currentBladeBehavior;
bladeBehavior previousBladeBehavior;


/*******************************************************************************
 * CONTROL PANEL: These are the only settings that you'll need to customize as
 * long as your blade matches the hardware/layout specified above. More than
 * that, no promises!
 ******************************************************************************/

#define INIT_BLADE_EXTENDED false
#define INIT_IN_PARTY_MODE false
#define DEFAULT_NORMAL_BEHAVIOR stable
#define DEFAULT_PARTY_BEHAVIOR rainbow

#define DEFAULT_SATURATION 255 // 0 = gray, to 255 = full color
#define DEFAULT_VALUE 150 // 0 = no luminence, to 255 = fully bright

// Smaller values result in smoother transitions between colors but
// you won't see as many colors at once in some animations.
#define DEFAULT_DELTA_HUE 2

// Smaller values speed animations up, Larger value slow them down.
#define ANIMATION_SPEED 40


void setup() {

#ifdef DEBUG

    Serial.begin(9600);
    while(!Serial){};

#endif

    initPropShield();
    initInputs();
    initStateVariables();
    initLED();

} // end setup


void loop() {

    // Check whether we should toggle the blade.
    if(shouldBladeToggle) {

        toggleBlade();
        shouldBladeToggle = false; // reset flag

    }

    // Only update if blade is extended.
    if(isBladeExtended) {

        if(shouldModeChange) {

            changeMode();
            shouldModeChange = false; // reset flag

        }

        if(shouldBehaviorChange) {

            changeBladeBehavior();
            shouldBehaviorChange = false; // reset flag
            behaviorChanged = true;

        }

        if(isPartyMode) {

            switch(currentBladeBehavior) {
                case rainbow:
                    rainbowAnimation();
                    break;
                case rainbowWithGlitter:
                    rainbowWithGlitterAnimation();
                    break;
                case verticalRainbow:
                    verticalRainbowAnimation();
                    break;
                case confetti:
                    confettiAnimation();
                    break;
                case cylon:
                    cylonAnimation();
                    break;
                case bpm:
                    bpmAnimation();
                    break;
                case juggle:
                    juggleAnimation();
                    break;
                default:
                    rainbowAnimation(); // choose what you like.
                    break;

            } // end party mode animation switch

        } else {

            switch(currentBladeBehavior) {

                case stable:
                    stableBladeAnimation();
                    break;
                case unstable:
                    unstableBladeAnimation();
                    break;
                case pulsing:
                    pulsingBladeAnimation();
                    break;
                default:
                    // DO SOMETHING
                    break;

            } // end normal mode animation switch

        } // end animation if/else block

    }

    FastLED.show();

} // end loop


/*******************************************************************************
 * Use this method to initialize the prop shield.
 ******************************************************************************/
void initPropShield() {

    // Give the audio some memory but note the max used while cycling through
    // final set. Whatever value is greatest is how much you should set aside
    // using AudioMemory() below so update appropriately.
    AudioMemory(10);

    // Enable the audio amp.
    pinMode(ENABLE_AMP_PIN, OUTPUT);
    digitalWrite(ENABLE_AMP_PIN, HIGH);
    delay(10); // Takes a few ticks to kick in.

    // Turn up the amp's power.
    dac.analogReference(EXTERNAL);

    // Enable the serial flash.
    if (!SerialFlash.begin(ENABLE_FLASH_PIN)) {

#ifdef DEBUG

        // No point proceeding if flash won't start so loop an error.
        while (1) {

            Serial.println ("FLASH not enabled");
            delay (3000);

        }

#endif

    }

} // end initPropShield


/*******************************************************************************
 * This is a "common purpose" function, used to group the initialization of
 * attached input devices.
 ******************************************************************************/
void initInputs() {

    // First setup all button pins.
    pinMode(TOGGLE_BLADE_PIN, INPUT);
    pinMode(CHANGE_MODE_PIN, INPUT);
    pinMode(CYCLE_BEHAVIOR_PIN, INPUT);

    // Attach desired interrupt routines to each button.
    attachInterrupt(digitalPinToInterrupt(TOGGLE_BLADE_PIN),
        toggleBladeInterrupt, RISING);
    attachInterrupt(digitalPinToInterrupt(CHANGE_MODE_PIN),
        changeModeInterrupt, RISING);
    attachInterrupt(digitalPinToInterrupt(CYCLE_BEHAVIOR_PIN),
        changeBladeBehaviorInterrupt, RISING);

#ifdef DEBUG

    Serial.println("Inputs Initialized");

#endif

} // end initInputs


/*******************************************************************************
 * This is a "common purpose" function, used to group the initialization of more
 * general state variables... not those specific to a specific piece or harware
 * or library.
 ******************************************************************************/
void initStateVariables(){

    isBladeExtended = INIT_BLADE_EXTENDED;
    shouldBladeToggle = false;
    shouldModeChange = false;
    shouldBehaviorChange = false;

    // Leave true so the default behavior will be initialized.
    behaviorChanged = true;

#if INIT_IN_PARTY_MODE

    isPartyMode = true;
    currentBladeBehavior = DEFAULT_PARTY_BEHAVIOR;
    previousBladeBehavior = DEFAULT_NORMAL_BEHAVIOR:

#else

    isPartyMode = false;
    currentBladeBehavior = DEFAULT_NORMAL_BEHAVIOR;
    previousBladeBehavior = DEFAULT_PARTY_BEHAVIOR;

#endif

#ifdef DEBUG

    Serial.println("State variables initialized.");

#endif

} // end initStateVariables


/*******************************************************************************
 * This is a "common purpose" function, used to group the initialization of
 * attached addressable LEDs.
 ******************************************************************************/
void initLED() {

    currentHue = retrieveHue();
    baseSaturation = DEFAULT_SATURATION;
    baseValue = DEFAULT_VALUE;

    FastLED.addLeds<PIXEL_TYPE, LIGHT_STRIP_PIN, COLOR_ORDER>(pixelsRGB,
        NUM_PIXELS);
    initPixels();
    FastLED.show();

#ifdef DEBUG

    Serial.println("All LED's Initialized");

#endif

} // end initLED


/*******************************************************************************
 * This is a helper function used to group initialization of, in this case, a
 * strip of WS2812B addressable LEDs.
 ******************************************************************************/
void initPixels() {

    for(int i = 0; i < NUM_PIXELS; i++) {

        pixelsRGB[i] = pixelsHSV[i] = CHSV(currentHue, baseSaturation, 0);

    }

#ifdef DEBUG

    Serial.println("Pixels Initialized");

#endif

} // end initPixels


/*******************************************************************************
 * This function is used to retrieve the currently requested hue.
 *
 * @return - An integer value between 0 and 255 specifying a new hue.
 ******************************************************************************/
int retrieveHue() {

    return map(analogRead(HUE_PIN), 0, 1023, 0, 255);

} // end retrieveHue


/*******************************************************************************
 * This function will toggle the blade between retracted and extended states.
 ******************************************************************************/
void toggleBlade() {

    if(isBladeExtended) { // We should retract the blade.

        retractBlade();

    } else { // We should extend the blade.

        extendBlade();

    }

    isBladeExtended = !isBladeExtended;

#ifdef DEBUG
    if(isBladeExtended) {

        Serial.println("Blade is growing");

    } else {

        Serial.println("Blade is going down");

    }
#endif

} // end toggleBlade


/*******************************************************************************
 * This function will retract the blade.
 ******************************************************************************/
void retractBlade() {

    for(int i = NUM_PIXELS - 1; i >= 0; i--) {

        pixelsHSV[i].value = 0;
        pixelsRGB[i] = pixelsHSV[i];
        FastLED.show();

    }

} // end retractBlade


/*******************************************************************************
 * This function will extend the blade.
 ******************************************************************************/
void extendBlade() {

    static unsigned long lastUpdateTime = 0;
    static unsigned long animationDelay;
    static boolean firstPass = true;

    extendSoundPlayer.play(extendBladeTrack);

    if(firstPass) {

        animationDelay = extendSoundPlayer.lengthMillis() / NUM_PIXELS;
        firstPass = false;

    } // end first pass routine

    int i = 0;
    while(i < NUM_PIXELS) {

        if(hasEnoughTimePassed(animationDelay, lastUpdateTime)) {

            pixelsHSV[i].value = baseValue;
            pixelsRGB[i] = pixelsHSV[i];
            FastLED.show();

            lastUpdateTime = millis();
            i++;

        }

    }

} // end extendBlade


/*******************************************************************************
 * This function will change the blades current mode.
 ******************************************************************************/
void changeMode() {

    // Swap behaviors going between modes.
    bladeBehavior tempBladeBehavior = currentBladeBehavior;
    currentBladeBehavior = previousBladeBehavior;
    previousBladeBehavior = tempBladeBehavior;

    // Set flags appropriately.
    isPartyMode = !isPartyMode;
    behaviorChanged = true;

#ifdef DEBUG
    if(isPartyMode) {

        Serial.println("Party Mode Y'all");

    } else {

        Serial.println("Normal Mode");

    }
#endif

} // end changeMode


/*******************************************************************************
 * This function will change the blades current behavior. Which behaviors will
 * be cycled depends on the current mode.
 ******************************************************************************/
void changeBladeBehavior() {

    if(isPartyMode) {

        switch(currentBladeBehavior) {

            case rainbow:
                currentBladeBehavior = rainbowWithGlitter;
                break;
            case rainbowWithGlitter:
                currentBladeBehavior = verticalRainbow;
                break;
            case verticalRainbow:
                currentBladeBehavior = confetti;
                break;
            case confetti:
                currentBladeBehavior = cylon;
                break;
            case cylon:
                currentBladeBehavior = bpm;
                break;
            case bpm:
                currentBladeBehavior = juggle;
                break;
            case juggle:
            default:
                currentBladeBehavior = rainbow;
                break;

        }

    } else {

        switch(currentBladeBehavior) {

            case stable:
                currentBladeBehavior = unstable;
                break;
            case unstable:
                currentBladeBehavior = pulsing;
                break;
            case pulsing:
            default:
                currentBladeBehavior = stable;
                break;

        }

    }

#ifdef DEBUG
    Serial.print("Behavior changed to ");
    Serial.println(currentBladeBehavior);
#endif

} // end changeBehavior


void rainbowAnimation() {

    static int baseHue;
    static unsigned long lastUpdateTime = 0L;

    if(behaviorChanged) {

        baseHue = initRainbowAnimation();
        behaviorChanged = !behaviorChanged;

    }

    if(hasEnoughTimePassed(ANIMATION_SPEED, lastUpdateTime)) {

        CHSV hsv;
        hsv.hue = baseHue;
        hsv.sat = DEFAULT_SATURATION;
        hsv.val = DEFAULT_VALUE;
        for( int i = 0; i < NUM_PIXELS; i++) {

            pixelsRGB[i] = hsv;

        }

        baseHue += DEFAULT_DELTA_HUE;
        lastUpdateTime = millis();

    }

} // end rainbowAnimation


int initRainbowAnimation() {

    // Think of a way to smoothly fade each pixel to the desired color.

#ifdef DEBUG

    Serial.println("Starting RAINBOW animation");

#endif

    return retrieveHue();

} // end initRainbowAnimation


void rainbowWithGlitterAnimation() {

    static int baseHue;
    static unsigned long lastUpdateTime = 0L;

    if(behaviorChanged) {

        baseHue = initRainbowWithGlitterAnimation();
        behaviorChanged = !behaviorChanged;

    }

    if(hasEnoughTimePassed(ANIMATION_SPEED, lastUpdateTime)) {

        CHSV hsv;
        hsv.hue = baseHue;
        hsv.sat = DEFAULT_SATURATION;
        hsv.val = DEFAULT_VALUE;
        for( int i = 0; i < NUM_PIXELS; i++) {

            pixelsRGB[i] = hsv;

        }

        addGlitter(250);

        baseHue += DEFAULT_DELTA_HUE;
        lastUpdateTime = millis();

    }

} // end rainbowWithGlitter()


int initRainbowWithGlitterAnimation() {

    // Think of a way to smoothly fade each pixel to the desired color.

#ifdef DEBUG

    Serial.println("Starting RAINBOW w/Glitter animation");

#endif

    return retrieveHue();

} // end initRainbowWithGlitterAnimation


void verticalRainbowAnimation() {

    static int baseHue;
    static unsigned long lastUpdateTime = 0L;

    if(behaviorChanged) {

        baseHue = initVerticalRainbow();
        behaviorChanged = !behaviorChanged;

    }

    if(hasEnoughTimePassed(ANIMATION_SPEED, lastUpdateTime)) {

        CHSV hsv;
        hsv.hue = baseHue;
        hsv.sat = DEFAULT_SATURATION;
        hsv.val = DEFAULT_VALUE;
        for( int i = 0; i < NUM_PIXELS; i++) {
            pixelsRGB[i] = hsv;
            hsv.hue += DEFAULT_DELTA_HUE;
        }

        baseHue += DEFAULT_DELTA_HUE;
        lastUpdateTime = millis();

    }

} // end verticalRainbowAnimation


int initVerticalRainbow() {

    // Think of a way to smoothly fade each pixel to the desired color.

#ifdef DEBUG

    Serial.println("Starting VERTICAL RAINBOW animation");

#endif

    return retrieveHue();

} // end initVerticalRainbow


void confettiAnimation() {

    if(behaviorChanged) {

        initConfettiAnimation();
        behaviorChanged = !behaviorChanged;

    }

} // end confettiAnimation


void initConfettiAnimation() {

#ifdef DEBUG

        Serial.println("Starting CONFETTI animation");

#endif

} // end initConfettiAnimation


void cylonAnimation() {

    if(behaviorChanged) {

        initCylonAnimation();
        behaviorChanged = !behaviorChanged;

    }

} // end cylonAnimation


void initCylonAnimation() {

#ifdef DEBUG

    Serial.println("Starting CYLON animation");

#endif

} // end initCylonAnimation


void bpmAnimation() {

    if(behaviorChanged) {

        initBPMAnimation();
        behaviorChanged = !behaviorChanged;

    }

} // end bpmAnimation


void initBPMAnimation() {

#ifdef DEBUG

        Serial.println("Starting BPM animation");

#endif

} // end initBPMAnimation


void juggleAnimation() {

    if(behaviorChanged) {

        initJuggleAnimation();
        behaviorChanged = !behaviorChanged;

    }

} // end juggleAnimation


void initJuggleAnimation() {

#ifdef DEBUG

    Serial.println("Starting JUGGLE animation");

#endif

} // end initJuggleAnimation


void stableBladeAnimation() {

    int tempHue = retrieveHue();

    if(behaviorChanged) {

        initStableBladeAnimation();
        behaviorChanged = !behaviorChanged;

    }

    // Only update if a change was made.
    if(tempHue != currentHue) {

        changeHue(tempHue);

    }

} // end stableBladeAnimation


void initStableBladeAnimation() {

    changeHue(retrieveHue());

#ifdef DEBUG

        Serial.println("Starting STABLE animation");

#endif

} // end initStableBladeAnimation


void unstableBladeAnimation() {

    int tempHue = retrieveHue();

    if(behaviorChanged) {

        initUnstableBladeAnimation();
        behaviorChanged = !behaviorChanged;

    }

    // Only update if a change was made.
    if(tempHue != currentHue) {

        changeHue(tempHue);

    }

    // Reset all the values.
    for(int i = 0; i < NUM_PIXELS; i++) {

        pixelsRGB[i] = pixelsHSV[i].value = DEFAULT_VALUE;

    }

    addSparkle(150);

} // end unstableBladeAnimation


void initUnstableBladeAnimation() {

    changeHue(retrieveHue());

#ifdef DEBUG

        Serial.println("Starting UNSTABLE animation");

#endif

} // end initUnstableBladeAnimation


void pulsingBladeAnimation() {

    int tempHue = retrieveHue();

    if(behaviorChanged) {

        initPulsingBladeAnimation();
        behaviorChanged = !behaviorChanged;

    }

    // Only update if a change was made.
    if(tempHue != currentHue) {

        changeHue(tempHue);

    }

} // end pulsingBladeAnimation


void initPulsingBladeAnimation() {

    changeHue(retrieveHue());

#ifdef DEBUG

        Serial.println("Starting PULSING animation");

#endif

} // end initPulsingBladeAnimation


/*******************************************************************************
 * This is an add-on effect to any animation. It will cause random "glitter" or
 * bright white spots to appear in addition to the normal animation.
 *
 * @param chanceOfGlitter - An unsigned integer between 0 and 255. The larger
 * the value, the greater the chance of glitter to appear.
 ******************************************************************************/
void addGlitter(uint8_t chanceOfGlitter) {

  if(random8() < chanceOfGlitter) {

    pixelsRGB[random16(NUM_PIXELS)] += CRGB::White;

  }

} // end addGlitter


/*******************************************************************************
 * This is an add-on effect to any animation. It will cause random "sparkle" or
 * bright spots to appear in addition to the normal animation.
 *
 * @param chanceOfSparkle - An unsigned integer between 0 and 255. The larger
 * the value, the greater the chance of sparkle to appear.
 ******************************************************************************/
void addSparkle(uint8_t chanceOfSparkle) {

  if(random8() < chanceOfSparkle) {

    int tempIndex = random16(NUM_PIXELS);
    CHSV tempCHSV = pixelsHSV[tempIndex];
    tempCHSV.value = 255;
    pixelsRGB[tempIndex] = tempCHSV;

  }

} // end addSparkle


/*******************************************************************************
 * This function is used to update all pixels with a specified hue.
 *
 * @param newHue - The new/replacement hue.
 ******************************************************************************/
void changeHue(int newHue) {

    currentHue = newHue;
    for(int i = 0; i < NUM_PIXELS; i++) {

        pixelsHSV[i].hue = currentHue;
        pixelsRGB[i] = pixelsHSV[i];

    }

} // end changeHue


/*******************************************************************************
 * This is a helper class to ensure certain events don't happen within a
 * certain timeframe.
 *
 * @param delayInterval - The time to delay between perform the event again.
 * @param lastUpdateTime - The millisecond the event happened last.
 *
 * @return - A boolean true if enough time has passed, otherwise false.
 ******************************************************************************/
boolean hasEnoughTimePassed(unsigned long delayInterval,
    unsigned long lastUpdateTime) {

  return (millis() - lastUpdateTime) >= delayInterval;

} // end hasEnoughTimePassed


/*******************************************************************************
 * This is the ISR triggered when the Toggle Blade button is pressed.
 ******************************************************************************/
void toggleBladeInterrupt() {

    shouldBladeToggle = true;

} // end toggleBladeInterrupt


/*******************************************************************************
 * This is the ISR triggered when the Change Mode button is pressed.
 ******************************************************************************/
void changeModeInterrupt() {

    shouldModeChange = true;

} // end changeModeInterrupt


/*******************************************************************************
 * This is the ISR triggered when the Change Behavior button is pressed.
 ******************************************************************************/
void changeBladeBehaviorInterrupt() {

    shouldBehaviorChange = true;

} // end changeBladeBehaviorInterrupt
